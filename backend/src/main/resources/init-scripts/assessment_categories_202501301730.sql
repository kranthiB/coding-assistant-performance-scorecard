INSERT INTO public.assessment_categories (assessment_id,"name",score,created_at,note) VALUES
	 (2,'Intelligence','{"score": {"autonomy":4,"outputQuality":5,"contextAwareness":5} }','2025-01-30 12:11:59.875902+05:30','{"note": "{"autonomy":"Tabnine is far from an autonomous coding assistant. Unlike Copilot, which can suggest entire function bodies, Tabnine primarily enhances autocompletion rather than making big-picture suggestions. It doesn’t proactively refactor code, debug issues, or generate multi-step solutions. You have to manually drive the development process and rely on small incremental completions.","outputQuality":"The code generated by Tabnine is often correct but generic. It lacks nuanced optimizations and sometimes suggests overly simplistic or inefficient implementations. Since it doesn’t rely on large transformer models like Copilot, its code quality is more predictable but less intelligent. It’s good for small code completions but not ideal for complex logic or refactoring.","contextAwareness":"Tabnine lacks deep context awareness compared to GitHub Copilot. It focuses more on local suggestions (e.g., within a single function or file) but struggles with multi-file references or complex project structures. It doesn’t remember previous interactions well and fails to infer relationships between different parts of a codebase. While it provides decent autocomplete suggestions, it often lacks a broader project-wide understanding."}" }'),
	 (2,'Acceleration','{"score": {"capabilities":5,"iterationSize":5,"iterationSpeed":5} }','2025-01-30 12:11:59.875902+05:30','{"note": "{"capabilities":"Tabnine supports multiple languages but doesn’t provide advanced capabilities like Copilot’s in-depth framework knowledge. It struggles with interpreting comments, inferring logic from surrounding code, and working across different files in a project. It lacks deep learning-based reasoning, making it more of an enhanced autocomplete tool rather than an AI-powered assistant.","iterationSize":"Tabnine works best for small to medium iterations, like function signatures, variable completions, and short logic blocks. However, when asked to generate entire functions, classes, or refactor large portions of code, it doesn’t perform well. It lacks the ability to handle multi-line code generation effectively.","iterationSpeed":"Tabnine is relatively fast, but since it doesn’t use a large cloud-based AI model, its predictions are sometimes less relevant compared to Copilot. Since its primary function is auto-completion rather than full-line or full-function prediction, the iteration process is slower and more manual."}" }'),
	 (2,'Experience','{"score": {"flexibility":5,"reliability":5,"easeOfUse":8} }','2025-01-30 12:11:59.875902+05:30','{"note": "{"flexibility":"Tabnine works well with simple, structured coding tasks but doesn’t adapt well to unconventional programming styles. It’s decent for short-term use but struggles with long-term consistency across a codebase. Developers working with complex architectures may find it rigid and less helpful for customized solutions.","reliability":"Since Tabnine runs locally, it is more stable than cloud-based tools like Copilot, but its suggestions are sometimes hit-or-miss. It doesn’t always generate relevant or accurate code, and because it lacks deep context awareness, its reliability in long coding sessions diminishes.","easeOfUse":"One of Tabnine’s strongest aspects is ease of use. It integrates seamlessly into multiple IDEs, has minimal setup, and runs locally, which means no cloud dependencies. It’s a lightweight tool, making it smoother and less intrusive compared to Copilot, which requires continuous cloud communication."}" }'),
	 (2,'Value','{"score": {"value":7} }','2025-01-30 12:11:59.875902+05:30','{"note": "{"value":"Tabnine’s free version is a great starting point, and its paid version ($12/month) is more affordable than Copilot. However, because its feature set is more limited, its value depends on what you need. If you only need basic autocompletion with privacy-first local execution, Tabnine is a good choice. But if you need a true AI-powered coding assistant, Copilot or Cursor is a better value proposition."}" }'),
	 (3,'Acceleration','{"score": {"capabilities":4,"iterationSize":4,"iterationSpeed":5} }','2025-01-30 12:12:04.426604+05:30','{"note": "{"capabilities":"Codeium supports multiple programming languages but lacks deep framework-specific knowledge. It is not optimized for debugging, refactoring, or understanding complex system architectures. It’s good for quick code generation, but if you need an AI tool that understands high-level software engineering concepts, it’s not the best choice.","iterationSize":"Codeium performs best when generating small snippets or incremental suggestions. However, it struggles with longer completions—often losing coherence and failing to maintain logical flow over multi-line code. Unlike Copilot or Cursor, which can handle full function generation, Codeium is better suited for shorter completions rather than large-scale iterations.","iterationSpeed":"Codeium is reasonably fast, but its suggestions aren’t always relevant. While it delivers code at a decent speed, it sometimes requires multiple iterations to get a useful output, leading to a slower workflow overall. The speed is decent, but because the quality isn’t always great, you might spend extra time correcting its output."}" }'),
	 (4,'Value','{"score": {"value":6} }','2025-01-30 12:12:08.598671+05:30','{"note": "{"value":"Amazon Q is not the most expensive, but its true value is tied to AWS usage. If you heavily use AWS services, it’s a good investment, but if you’re not in the AWS ecosystem, it doesn’t offer much over Copilot or Cursor. It’s a decent value for cloud-native developers but an unnecessary expense for general software engineers."}" }'),
	 (5,'Value','{"score": {"value":7} }','2025-01-30 12:12:13.58897+05:30','{"note": "{"value":"Cursor is not cheap, but its capabilities justify the price. While it is not free like Codeium, it offers a better coding experience than Copilot in some cases, especially for refactoring and iteration handling. However, for developers who don’t need frequent AI-assisted coding, the price may not be worth it."}" }'),
	 (6,'Value','{"score": {"value":8} }','2025-01-30 12:12:18.522898+05:30','{"note": "{"value":"Windsurf provides good value for its cost, as it is cheaper than Copilot and Cursor while offering decent AI-assisted coding support. It is a solid mid-tier option, making it a good choice for developers who want AI assistance without paying for the most premium tools."}" }'),
	 (7,'Value','{"score": {"value":9} }','2025-01-30 12:12:23.91266+05:30','{"note": "{"value":"The biggest advantage of CodeGPT is that it is open-source and can be self-hosted, allowing developers to customize and fine-tune their own AI coding models. For those who want full control over their AI assistant without relying on paid services, CodeGPT is a fantastic value proposition. However, the trade-off is lower quality and less reliability compared to paid solutions."}" }'),
	 (1,'Experience','{"score": {"flexibility":7,"reliability":7,"easeOfUse":9} }','2025-01-30 12:11:55.253836+05:30','{"note": "{"flexibility":"Copilot works well in structured environments (web dev, scripting, API calls) but struggles with highly dynamic, custom frameworks or unconventional programming paradigms. It doesn’t adapt well to non-standard coding styles and sometimes forces generic solutions instead of aligning with project-specific needs. While it can adjust based on user inputs, its flexibility is limited by its training data and prebuilt models.","reliability":"Copilot is mostly reliable, but there are occasional issues with server outages, slow responses, and sometimes unpredictable behavior. While the AI is consistent in structured environments, in highly dynamic coding workflows, it can become unreliable—suggesting irrelevant code snippets, repeating the same suggestion, or failing to adapt. Additionally, offline usage is limited, making it dependent on cloud connectivity.","easeOfUse":"One of Copilot’s biggest strengths is its seamless usability. It requires no complex setup, works out of the box in most popular IDEs, and integrates directly into your workflow. The interface is minimal, non-intrusive, and intuitive. Suggestions appear as you type, and switching between them is simple. However, fine-tuning Copilot’s behavior or configuring advanced settings isn’t as flexible as some newer AI coding assistants (e.g., Cursor)."}" }');
INSERT INTO public.assessment_categories (assessment_id,"name",score,created_at,note) VALUES
	 (4,'Experience','{"score": {"flexibility":6,"reliability":6,"easeOfUse":8} }','2025-01-30 12:12:08.598671+05:30','{"note": "{"flexibility":"Amazon Q excels in AWS-centric projects but struggles outside the cloud environment. It’s not as adaptable as Copilot or Cursor when working with custom frameworks, unique architectures, or multi-language projects. If you’re working on serverless applications or cloud automation, it’s a solid tool, but for traditional software development, its value is limited.","reliability":"Amazon Q Developer is fairly reliable within AWS environments, but its suggestions degrade in quality when working with other tech stacks. If AWS updates or changes services, some generated code might become outdated. Additionally, downtime or API rate limits within AWS can impact its performance, making it less reliable for mission-critical applications.","easeOfUse":"One of the strongest aspects of Amazon Q is its smooth integration within AWS services. If you’re an AWS developer, it’s easy to use and fits naturally into existing workflows. It integrates well with IDE plugins, AWS CLI, and Infrastructure as Code (IaC) tools. However, if you’re not an AWS-focused developer, the setup and workflow are less intuitive, making Copilot or Cursor a better alternative."}" }'),
	 (5,'Intelligence','{"score": {"autonomy":7,"outputQuality":8,"contextAwareness":8} }','2025-01-30 12:12:13.58897+05:30','{"note": "{"autonomy":"Cursor is more autonomous than Codeium or Tabnine, actively assisting with code completion, refactoring, and iterative improvements. However, it doesn’t fully automate debugging or make independent high-level design choices. While it can assist with structuring and cleaning code, you still need to manually prompt it for corrections and optimizations.","outputQuality":"Cursor generates high-quality, readable, and production-ready code in most cases. It avoids unnecessary boilerplate, and understands complex logic better than Tabnine or Codeium. However, while its suggestions are generally better structured, they are not always optimized for performance. It still requires developer oversight for best results.","contextAwareness":"Cursor outperforms most AI coding assistants in context awareness, keeping track of project-wide dependencies, multi-file structures, and logical flow better than Copilot. It remembers interactions within a session, making it easier to maintain continuity. However, it occasionally loses track of deeper architectural dependencies, and its context retention is limited to session-based interactions rather than long-term memory across different coding sessions."}" }'),
	 (5,'Acceleration','{"score": {"capabilities":9,"iterationSize":8,"iterationSpeed":9} }','2025-01-30 12:12:13.58897+05:30','{"note": "{"capabilities":"Cursor is one of the most capable AI coding assistants, supporting multiple languages, frameworks, and workflows. It integrates well with Python, JavaScript, TypeScript, Go, Rust, and backend frameworks. Unlike Amazon Q, which is AWS-focused, or Tabnine, which is lightweight but limited, Cursor offers broad flexibility and can handle both frontend and backend development effectively.","iterationSize":"Cursor is excellent at handling both small and large iterations. It can generate entire functions, and rewrite/refactor multiple lines of code effectively. It does a better job at iterative improvement than Copilot, but it isn’t perfect when handling complex, multi-file changes, sometimes requiring manual adjustments for large-scale edits.","iterationSpeed":"One of Cursor’s biggest strengths is its speed. Code completions appear instantly, and its iteration process is smoother than most competitors. Unlike Copilot, which sometimes requires re-prompting for alternative suggestions, Cursor offers quick adjustments and refactor suggestions on demand. This makes it highly effective for fast-paced development cycles"}" }'),
	 (1,'Intelligence','{"score": {"autonomy":6,"outputQuality":8,"contextAwareness":7} }','2025-01-30 12:11:55.253836+05:30','{"note": "{"autonomy":"Copilot is not truly autonomous—it doesn’t proactively refactor, suggest improvements, or independently debug issues. It relies heavily on user inputs and requires continuous prompting to get to the desired solution. While it can auto-complete code and fill in missing logic, it won’t automatically rewrite inefficient code or detect issues unless specifically asked. In essence, it’s more of an enhanced autocomplete tool rather than an AI agent that can work without human guidance.","outputQuality":"Copilot generates syntactically correct, idiomatic, and often production-ready code for many languages. However, it sometimes hallucinates incorrect solutions, makes assumptions that don’t always align with business logic, and generates redundant or over-engineered code instead of concise solutions. It also struggles with optimizing for performance and may lack awareness of best practices in certain frameworks or tech stacks. That said, it’s still among the best AI tools for generating clean and readable code.","contextAwareness":"GitHub Copilot does a decent job of understanding local context, such as variables, functions, and recently edited code. However, it struggles with multi-file projects, doesn’t fully understand dependencies between files, and forgets prior context over long sessions. While it can infer intent from inline comments and docstrings, it often needs additional clarification. It’s good but not perfect at maintaining session-wide understanding, especially in large projects."}" }'),
	 (1,'Value','{"score": {"value":6} }','2025-01-30 12:11:55.253836+05:30','{"note": "{"value":"At $10/month for individuals and $19/month for teams, Copilot is one of the more expensive AI coding assistants. While it offers great functionality, some free alternatives (Codeium, Tabnine Free) provide decent performance. Also, Copilot’s value is diminished for developers who don’t rely heavily on AI-generated code. While the price is justified for power users, it’s not the best option for casual programmers or those on a budget."}" }'),
	 (5,'Experience','{"score": {"flexibility":9,"reliability":8,"easeOfUse":9} }','2025-01-30 12:12:13.58897+05:30','{"note": "{"flexibility":"Cursor adapts well to different programming styles, coding conventions, and architectures. It supports different workflows and integrates well into existing developer environments. Unlike Codeium, which struggles with customized solutions, Cursor performs well across multiple paradigms (OOP, functional programming, etc.) and is one of the most adaptable AI assistants available.","reliability":"Cursor is more reliable than most AI coding assistants, but it still has occasional inconsistencies. Some suggestions may be redundant or require manual fine-tuning, and it sometimes struggles with highly complex refactoring tasks. However, it is generally dependable and does not suffer from the same frequent inaccuracies as Codeium or Tabnine.","easeOfUse":"Cursor’s interface is smooth, intuitive, and easy to use. It integrates seamlessly into VS Code, JetBrains IDEs, and other popular development environments. Unlike Amazon Q, which has an AWS-specific workflow, or Tabnine, which has limited interactive features, Cursor offers a well-balanced, user-friendly experience with minimal setup required."}" }'),
	 (6,'Intelligence','{"score": {"autonomy":5,"outputQuality":7,"contextAwareness":6} }','2025-01-30 12:12:18.522898+05:30','{"note": "{"autonomy":"Windsurf is not very autonomous—it requires significant prompting to generate meaningful code structures. Unlike Cursor, which actively refactors and suggests improvements, Windsurf waits for direct input. While it does a decent job at inline suggestions, it doesn’t independently optimize or debug code unless explicitly guided.","outputQuality":"Windsurf generates mostly clean and structured code, but its quality is inconsistent across different programming languages and frameworks. While it is better than Tabnine or Codeium, it is not as polished as Copilot or Cursor. It sometimes repeats unnecessary patterns or lacks optimization in performance-sensitive code.","contextAwareness":"Windsurf has decent but not exceptional context awareness. It understands recent code snippets, local functions, and variable usage but struggles with multi-file projects and dependencies. It maintains short-term memory well, but over longer coding sessions, it forgets deeper project-wide relationships, making it less reliable for large-scale software development."}" }'),
	 (6,'Acceleration','{"score": {"capabilities":7,"iterationSize":6,"iterationSpeed":7} }','2025-01-30 12:12:18.522898+05:30','{"note": "{"capabilities":"Windsurf supports multiple programming languages and frameworks, including Python, JavaScript, Java, and TypeScript. However, it lacks the deep framework-specific knowledge that Copilot or Amazon Q Developer provides. It is useful for general-purpose coding but not as refined for specialized workflows like cloud infrastructure, data science, or embedded systems.","iterationSize":"Windsurf can handle medium-sized code blocks effectively, but it struggles with large-scale code generation. It occasionally loses coherence in long functions, requiring manual fixes and re-prompting. It is better than Tabnine or Codeium at handling iterative improvements but falls short of Copilot and Cursor in structuring multi-step logic efficiently.","iterationSpeed":"Windsurf is fairly fast and delivers inline suggestions quickly. However, compared to Cursor or Copilot, it occasionally lags when processing larger code segments. Since it relies on a slightly smaller AI model, the speed is good but not best-in-class."}" }'),
	 (6,'Experience','{"score": {"flexibility":7,"reliability":6,"easeOfUse":7} }','2025-01-30 12:12:18.522898+05:30','{"note": "{"flexibility":"Windsurf is moderately flexible, working well in various coding styles and architectures. It is not as adaptable as Cursor, but it can handle most development workflows without major issues. Its suggestions are more predictable than Copilot’s, making it safer for structured environments but less dynamic for experimental development.","reliability":"Windsurf is mostly reliable, but sometimes produces redundant or low-value suggestions. It also has occasional inconsistencies in how it interprets function logic, leading to unnecessary rework. It is better than Codeium but less consistent than Copilot or Cursor","easeOfUse":"One of Windsurf’s strongest points is its intuitive and smooth integration with various IDEs. It is easy to set up, non-intrusive, and well-designed. Unlike Amazon Q, which requires AWS alignment, Windsurf works seamlessly across different development environments, making it a good option for those who prefer lightweight AI assistance."}" }'),
	 (1,'Acceleration','{"score": {"capabilities":8,"iterationSize":7,"iterationSpeed":8} }','2025-01-30 12:11:55.253836+05:30','{"note": "{"capabilities":"Copilot supports multiple languages (Python, Java, JavaScript, C++, Go, Rust, and more) and integrates seamlessly with VS Code, JetBrains IDEs, and Neovim. It’s great at boilerplate code generation, syntax fixes, and API usage examples. However, it’s not great at debugging, lacks deep architectural reasoning, and isn’t ideal for highly domain-specific use cases (e.g., complex data science, embedded systems). While it’s an excellent coding assistant, it’s not a full-fledged AI pair programmer.","iterationSize":"Copilot works best for short to medium-length suggestions—such as single functions, small scripts, or incremental improvements. However, when asked to generate an entire class, multi-step algorithm, or large block of code, it often loses coherence. The quality of long suggestions can vary; sometimes it misses key details or introduces logical flaws that require manual fixes. It’s not great at breaking large problems into smaller iterative improvements.","iterationSpeed":"Copilot is very fast, with near-instant completions appearing as you type. However, if you want alternative suggestions, you need to manually cycle through them, which slows down the process. When making larger-scale modifications (e.g., refactoring code across multiple functions), it doesn’t offer bulk edits or batch iterations—something newer AI coding tools (like Cursor) are improving on. Speed is one of its biggest strengths, but iteration efficiency could be better."}" }');
INSERT INTO public.assessment_categories (assessment_id,"name",score,created_at,note) VALUES
	 (3,'Intelligence','{"score": {"autonomy":3,"outputQuality":5,"contextAwareness":4} }','2025-01-30 12:12:04.426604+05:30','{"note": "{"autonomy":"Codeium is far from being autonomous—it does not proactively refactor, suggest improvements, or debug issues on its own. You must explicitly guide it, and even then, it often provides fragmented, short suggestions instead of coherent, multi-step solutions. It does not \"think ahead\" like a true AI assistant, making it more of an autocomplete tool than an AI-powered coding partner.","outputQuality":"The generated code is functional but often lacks refinement. While Codeium is good at completing boilerplate code and repetitive patterns, it sometimes misses nuances in business logic, edge cases, and optimization techniques. The suggestions are sometimes redundant, and while it’s helpful for standard programming tasks, it does not consistently produce high-quality, production-ready code like Copilot or Cursor.","contextAwareness":"Codeium lacks strong context awareness compared to GitHub Copilot or Cursor. While it can provide decent suggestions within a single function or file, it struggles with multi-file references and forgetting prior interactions. It cannot keep track of project-wide dependencies well and fails to infer context beyond the immediate code snippet. If you’re working on a long-term project, Codeium might not be reliable for deep context retention."}" }'),
	 (3,'Experience','{"score": {"flexibility":4,"reliability":4,"easeOfUse":7} }','2025-01-30 12:12:04.426604+05:30','{"note": "{"flexibility":"Codeium works well for general coding tasks, but it struggles in niche areas. It doesn’t handle complex development environments well and doesn’t adjust its recommendations based on unique project structures. While it does okay for standard development, it’s not as flexible as Copilot or Cursor in adapting to different workflows.","reliability":"Codeium is not highly reliable—it occasionally fails to provide relevant suggestions, struggles with long-term context retention, and lacks robust debugging assistance. While it’s not completely unusable, it’s also not dependable for complex projects, especially when dealing with large codebases. It’s fine for quick tasks but unreliable for serious development work.","easeOfUse":"One of Codeium’s strengths is its simple setup and ease of use. It integrates well with multiple IDEs, doesn’t require extensive configuration, and has a straightforward UI. However, its lack of advanced customization options makes it less flexible than Copilot or Cursor. It’s easy to use, but not as feature-rich as some alternatives."}" }'),
	 (3,'Value','{"score": {"value":9} }','2025-01-30 12:12:04.426604+05:30','{"note": "{"value":"The biggest selling point of Codeium is its price—it''s free for individual developers. While its capabilities aren’t as strong as Copilot or Cursor, it’s still a decent option for those who don’t want to pay for an AI coding assistant. If your priority is cost-efficiency over advanced AI functionality, Codeium is an excellent choice."}" }'),
	 (4,'Intelligence','{"score": {"autonomy":6,"outputQuality":6,"contextAwareness":6} }','2025-01-30 12:12:08.598671+05:30','{"note": "{"autonomy":"Amazon Q Developer is more proactive than Tabnine or Codeium but not as autonomous as Cursor or Copilot. It can generate useful code completions, AWS service integrations, and infrastructure templates without too much prompting. However, it doesn’t self-correct mistakes well, doesn’t refactor code autonomously, and still requires a fair amount of developer guidance to produce reliable output.","outputQuality":"The quality of the generated code is fairly decent, especially when working with AWS SDKs, Lambda functions, DynamoDB, or cloud infrastructure code (IaC). However, when used outside AWS-related workflows, it doesn’t generate as refined or optimized code as Copilot or Cursor. The code is often generic, and sometimes AWS-specific suggestions are pushed unnecessarily, which can be annoying for developers working on non-cloud projects.","contextAwareness":"Amazon Q Developer has better context awareness than Tabnine or Codeium but still falls short of GitHub Copilot and Cursor. Since it’s designed for AWS-integrated environments, it works well within Amazon’s ecosystem but struggles in general-purpose coding outside AWS services. It recognizes recent context fairly well within an IDE but loses track of multi-file dependencies, making it less effective for large-scale software development."}" }'),
	 (4,'Acceleration','{"score": {"capabilities":6,"iterationSize":6,"iterationSpeed":6} }','2025-01-30 12:12:08.598671+05:30','{"note": "{"capabilities":"Amazon Q shines in AWS-based development. If you’re working with Lambda, ECS, DynamoDB, IAM roles, or S3, it provides valuable insights, code templates, and cloud infrastructure recommendations. However, outside AWS, it’s not as powerful—it doesn’t handle backend logic, UI frameworks, or large-scale application development as well as Copilot or Cursor. It’s great for cloud-related workflows but limited beyond that.","iterationSize":"Amazon Q performs well when generating small-to-medium code snippets, especially when working within AWS environments. However, it struggles with generating long, multi-step implementations, losing coherence over extended function completions. Unlike Copilot, it doesn’t handle large-scale refactoring or big function generation effectively. It’s best for cloud-related tasks but mediocre in general-purpose programming.","iterationSpeed":"The tool is reasonably fast, but not as instant as Copilot or Cursor. Since some completions require AWS-specific integrations, it sometimes delays responses while pulling service-based recommendations. The response times are generally good, but the relevance of suggestions can vary, leading to extra iterations before getting a usable result."}" }'),
	 (7,'Intelligence','{"score": {"autonomy":3,"outputQuality":4,"contextAwareness":3} }','2025-01-30 12:12:23.91266+05:30','{"note": "{"autonomy":"CodeGPT is not an autonomous AI assistant—it requires constant manual guidance and corrections. It doesn’t refactor code proactively, detect issues independently, or suggest optimizations unless explicitly prompted. Unlike Cursor, which actively helps iterate on improvements, CodeGPT is more of a reactive tool that waits for instructions rather than suggesting proactive refinements.","outputQuality":"The quality of generated code is inconsistent. While CodeGPT can produce correct syntax and reasonable function completions, it often lacks optimization, efficiency, and best practices. It relies on general patterns rather than deep, context-aware generation, leading to generic and sometimes redundant solutions. Unlike Copilot or Cursor, it doesn’t always follow project conventions and can hallucinate incorrect solutions.","contextAwareness":"CodeGPT lacks strong context retention, especially when compared to Copilot or Cursor. It forgets previous interactions quickly, making it hard to maintain continuity in longer coding sessions. It can handle basic function-level context, but struggles with multi-file references, class structures, and project-wide dependencies. Its understanding of prior interactions is weak, requiring users to restate context frequently."}" }'),
	 (7,'Acceleration','{"score": {"capabilities":4,"iterationSize":3,"iterationSpeed":4} }','2025-01-30 12:12:23.91266+05:30','{"note": "{"capabilities":"CodeGPT supports multiple languages and frameworks, but its deep understanding of complex programming paradigms is weak. It doesn’t handle debugging, refactoring, or system-wide changes well. It also struggles with non-standard programming techniques, making it less effective for developers working outside of conventional coding patterns.","iterationSize":"CodeGPT struggles with large-scale code generation. It can handle small function completions fairly well, but as code complexity increases, its coherence drops significantly. If you ask it to generate a full class or multi-step logic, it often loses track of dependencies, requiring manual intervention to correct logic errors. It’s better suited for quick snippets rather than structured, multi-part coding tasks.","iterationSpeed":"The speed of CodeGPT is notably slower than Copilot or Cursor, especially when working with large prompts or context-heavy requests. While it can generate quick inline completions, longer responses can take several seconds to process, slowing down the development workflow. Additionally, regenerating alternative suggestions often takes longer than necessary, making it less efficient for iterative coding."}" }'),
	 (7,'Experience','{"score": {"flexibility":3,"reliability":3,"easeOfUse":5} }','2025-01-30 12:12:23.91266+05:30','{"note": "{"flexibility":"While CodeGPT is somewhat flexible, it doesn’t adapt well to unique project requirements. It can generate code in multiple languages, but its inability to deeply integrate with IDEs and workflows makes it less practical for large-scale software development. Unlike Copilot, which seamlessly integrates into development environments, CodeGPT requires manual copying and pasting of generated suggestions, making it a less efficient workflow tool.","reliability":"CodeGPT is not highly reliable—it often produces irrelevant, repetitive, or incorrect suggestions. Since it doesn’t fine-tune its responses based on project-specific context, the output can vary significantly in accuracy. Additionally, it struggles to maintain consistency across different prompts, making it unreliable for serious development work.","easeOfUse":"CodeGPT is easy to use as a chatbot, but its lack of tight IDE integration reduces efficiency. Unlike Copilot, which provides inline suggestions inside an IDE, CodeGPT requires a separate interface or manual prompting to generate code. This makes it less seamless compared to competitors. However, for developers who prefer chat-based AI interactions, it’s a reasonable tool for idea generation."}" }');
